#include <iostream>
#include <string>
#include <cctype>
#include <cstdlib>
 
using namespace std;
 
/* Global declarations */
/* Variables */
char nextChar;
string input;
 
/* Token definitions */
#define INT_LIT 10
#define IDENT 11
#define ASSIGN_OP 20
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26
 
/* Function declarations */
void getChar();
void expr();
void exprTail();
void term();
void termTail();
void factor();
 
/******************************************************/
/* main driver */
int main()
{
   cout << "Enter an arithmetic expression: ";
   getline(cin, input);
 
   getChar(); // Initialize nextChar
   expr();    // Parse the input arithmetic expression
 
   return 0;
}
 
/*****************************************************/
/* getChar - a function to get the next character of input and determine its
* character class */
void getChar() {
   if (!input.empty()) {
       nextChar = input[0];
       input.erase(0, 1);
       while (isspace(nextChar)) {
           if (!input.empty()) {
               nextChar = input[0];
               input.erase(0, 1);
           } else {
               break;
           }
       }
 
       if (!isdigit(nextChar) && nextChar != '+' && nextChar != '-' && nextChar != '*' && nextChar != '/' && nextChar != '(' && nextChar != ')') {
           cerr << "Error - unexpected character '" << nextChar << "'" << endl;
           exit(1);
       }
   } else {
       nextChar = '\0';
   }
}
 
/*****************************************************/
/* expr - parses strings in the language generated by the rule:
* <Expr> -> <Term> <ExprTail>
*/
void expr() {
   term();
   exprTail();
}
 
/*****************************************************/
/* exprTail - parses strings in the language generated by the rule:
* <ExprTail> -> + <Term> <ExprTail> | - <Term> <ExprTail> | e
*/
void exprTail() {
   if (nextChar == '+' || nextChar == '-') {
       char currentToken = nextChar;
       cout << "Next token is: " << ((currentToken == '+') ? ADD_OP : SUB_OP) << ", Next lexeme is " << currentToken << endl;
       getChar();
       term();
       exprTail();
   }
}
 
/*****************************************************/
/* term - parses strings in the language generated by the rule:
* <Term> -> <Factor> <TermTail>
*/
void term() {
   factor();
   termTail();
}
 
/*****************************************************/
/* termTail - parses strings in the language generated by the rule:
* <TermTail> -> * <Factor> <TermTail> | / <Factor> <TermTail> | e
*/
void termTail() {
   if (nextChar == '*' || nextChar == '/') {
       char currentToken = nextChar;
       cout << "Next token is: " << ((currentToken == '*') ? MULT_OP : DIV_OP) << ", Next lexeme is " << currentToken << endl;
       getChar();
       factor();
       termTail();
   }
}
 
/*****************************************************/
/* factor - parses strings in the language generated by the rule:
* <Factor> -> NUMBER | ( <Expr> )
*/
void factor() {
   if (isdigit(nextChar)) {
       while (isdigit(nextChar)) {
           cout << "Next token is: " << INT_LIT << ", Next lexeme is " << nextChar << endl;
           getChar();
       }
   } else if (nextChar == '(') {
       cout << "Next token is: " << LEFT_PAREN << ", Next lexeme is " << nextChar << endl;
       getChar(); // Consume '('
       expr();
       if (nextChar == ')') {
           cout << "Next token is: " << RIGHT_PAREN << ", Next lexeme is " << nextChar << endl;
           getChar(); // Consume ')'
       } else {
           cerr << "Error - missing right parenthesis" << endl;
           exit(1);
       }
   } else {
       cerr << "Error - unexpected token" << endl;
       exit(1);
   }
}
 
 